{
  "_documentation": {
    "_purpose": "Configuration file for the Network Device Monitor application",
    "_description": "This file controls the behavior of monitor.py, a multi-threaded network monitoring application that tracks device connectivity on a local network. The monitor uses two threads: a discovery thread that scans the entire subnet periodically, and a polling thread that pings known devices at a faster interval.",
    "_usage": "Edit these values to customize network scanning behavior, timing intervals, file locations, and logging settings. Changes require restarting the monitor service.",
    "_version": "1.0",
    "_last_updated": "2025-11-27"
  },

  "_network_settings": {
    "_description": "Core network configuration that defines what network range to monitor and which network interface to use for scanning"
  },
  "subnet": "192.168.4.0/24",
  "_subnet_info": "CIDR notation for the network range to monitor. Example: 192.168.1.0/24 covers 192.168.1.0-255. Must match your local network configuration. Used by the discovery thread to scan for all devices on the network.",

  "interface": "eth0",
  "_interface_info": "Network interface to use for scanning. Common values: 'eth0' for wired Ethernet, 'wlan0' for Wi-Fi. Must match an active network interface on your system. Run 'ip link show' to see available interfaces. This interface must be connected to the subnet you want to monitor.",

  "_timing_settings": {
    "_description": "Interval configurations that control how frequently the monitor performs different types of network checks. Lower values = more responsive but higher CPU/network usage. Higher values = less resource usage but slower detection of changes.",
    "_detection_timing": {
      "_new_device_discovery": "Average time to discover a NEW device coming online: Approximately (discovery_run_time + discovery_interval_seconds) / 2. With defaults (15s scan + 30s pause = 45s cycle), average discovery time is ~22 seconds. Worst case: 45 seconds if device appears just after a scan completes.",
      "_state_change_detection_online": "Average time to detect a known device coming ONLINE: Approximately (polling_run_time + polling_interval_seconds) / 2, OR next discovery scan, whichever comes first. Polling is usually faster. With 20 devices and defaults (20 × 3s = 60s + 3s pause = 63s cycle), average is ~31 seconds. Can also be detected immediately if discovery scan happens to run first. Note: The timestamp precision for when the device actually went OFFLINE previously is limited by the polling cycle time - we only know it was offline when last checked.",
      "_state_change_detection_offline": "Average time to detect a device going OFFLINE: Approximately (polling_run_time + polling_interval_seconds) / 2. Only the polling thread detects offline state. With 20 devices and defaults (63s cycle), average is ~31 seconds. To improve offline detection speed: reduce ping_timeout_seconds or ping_count, or run pings in parallel (requires code changes). Note: The timestamp precision for when the device actually went ONLINE previously is limited by the polling cycle time - we only know it was online when last checked."
    }
  },
  "discovery_interval_seconds": 30,
  "_discovery_interval_info": "Pause time (in seconds) between discovery scans. NOTE: This is the sleep time AFTER each scan completes, not the total interval. The actual time between scan starts = run time + this pause. Estimated run time: 5-30 seconds for typical home networks (depends on network size and response times). A /24 subnet with arp-scan typically takes 5-15 seconds, plus up to 60 seconds for fping ARP cache pre-population if enabled. Total cycle time example: 15s scan + 30s pause = 45s between scan starts. Recommended pause: 30-300 seconds. Lower values detect new devices faster but increase network/CPU usage. Default: 30",

  "polling_interval_seconds": 3,
  "_polling_interval_info": "Pause time (in seconds) between polling cycles. NOTE: This is the sleep time AFTER each polling round completes, not the total interval. The actual time between polling starts = run time + this pause. Estimated run time: (number_of_devices × ping_timeout_seconds). For example, 20 devices with 3-second ping timeout = ~60 seconds of pinging (done sequentially), plus this 3-second pause = 63s total cycle. For faster state change detection, reduce ping_timeout_seconds rather than this value. Recommended pause: 1-10 seconds. Default: 3",

  "_ping_settings": {
    "_description": "Configuration for ping-based connectivity checks used by the polling thread to determine if known devices are online or offline"
  },
  "ping_timeout_seconds": 3,
  "_ping_timeout_info": "Maximum time (in seconds) to wait for a ping response before considering a device offline. Should be less than or equal to polling_interval_seconds to avoid overlapping checks. Recommended: 1-5 seconds. Default: 3",

  "ping_count": 3,
  "_ping_count_info": "Number of ping packets to send per check. Higher values = more reliable but slower. Value of 1 = fastest but may have false negatives. Value of 3-5 = good balance. Default: 3",

  "parallel_ping_workers": 10,
  "_parallel_ping_workers_info": "Number of parallel threads to use for pinging devices. With parallel polling, all devices are checked simultaneously instead of sequentially. Higher values = faster polling cycles but more CPU/network usage. Value of 10-20 is typical for home networks. Default: 10",

  "parallel_stagger_ms": 50,
  "_parallel_stagger_ms_info": "Milliseconds to stagger the start of each ping thread. With 15 devices and 50ms stagger, threads start at 0ms, 50ms, 100ms, etc., spreading the network/CPU load over 750ms instead of all at once. Lower values = tighter grouping but higher burst load. Higher values = smoother load distribution. Recommended: 20-100ms. Default: 50",

  "_scanner_settings": {
    "_description": "Settings that control which network scanning tool is used for device discovery and how the ARP cache is managed"
  },
  "scanner": "arp-scan",
  "_scanner_info": "Primary network scanning tool for device discovery. Options: 'arp-scan' (faster, more reliable, recommended) or 'nmap' (slower but more widely available). The monitor will automatically fall back to nmap if arp-scan is not installed. Install arp-scan with: sudo apt-get install arp-scan",

  "prepopulate_arp": true,
  "_prepopulate_arp_info": "If true, runs fping to populate the system ARP cache before scanning. This significantly improves arp-scan accuracy and speed by ensuring the ARP cache is warm. Recommended: true. Requires fping to be installed: sudo apt-get install fping. If fping is not installed, this setting is safely ignored.",

  "_storage_settings": {
    "_description": "File paths and directory locations for device state storage and application logs"
  },
  "devices_dir": "devices",
  "_devices_dir_info": "Directory path (relative to monitor.py) where device state files are stored. Each monitored device gets its own CSV file named by MAC address (with colons removed). Files contain timestamp,ip,mac,status,interval_seconds on each line. This directory must be writable by the user running monitor.py. Do NOT run monitor.py with sudo or files will be owned by root.",

  "_logging_settings": {
    "_description": "Application logging configuration. Logs always go to stdout (captured by systemd journal when run as service). File logging is optional and intended for testing/debugging only."
  },
  "log_level": "INFO",
  "_log_level_info": "Logging verbosity level. Options (from least to most verbose): 'ERROR', 'WARNING', 'INFO', 'DEBUG'. 'INFO' shows all state changes and important events. 'DEBUG' shows detailed scanning operations and is useful for troubleshooting. 'WARNING' only shows problems. Default: INFO",

  "_vendor_lookup_settings": {
    "_description": "MAC address vendor identification configuration. Used to identify device manufacturers from MAC addresses for easier device identification in logs."
  },
  "common_vendors": {
    "_description": "Optional dictionary mapping MAC prefixes (first 6 hex digits) to vendor names for faster local lookup before querying external API. Example: '00:1A:2B': 'Apple Inc.'. This is a performance optimization to reduce API calls for common devices on your network. Leave empty to always use API lookup."
  }
}
