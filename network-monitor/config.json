{
  "_documentation": {
    "_purpose": "Configuration file for the Network Device Monitor application",
    "_description": "This file controls the behavior of monitor.py, a multi-threaded network monitoring application that tracks device connectivity on a local network. The monitor uses two threads: a discovery thread that scans the entire subnet periodically, and a polling thread that pings known devices at a faster interval.",
    "_usage": "Edit these values to customize network scanning behavior, timing intervals, file locations, and logging settings. Changes require restarting the monitor service.",
    "_version": "1.0",
    "_last_updated": "2025-11-27"
  },

  "_network_settings": {
    "_description": "Core network configuration that defines what network range to monitor and which network interface to use for scanning"
  },
  "subnet": "192.168.4.0/24",
  "_subnet_info": "CIDR notation for the network range to monitor. Example: 192.168.1.0/24 covers 192.168.1.0-255. Must match your local network configuration. Used by the discovery thread to scan for all devices on the network.",

  "interface": "eth0",
  "_interface_info": "Network interface to use for scanning. Common values: 'eth0' for wired Ethernet, 'wlan0' for Wi-Fi. Must match an active network interface on your system. Run 'ip link show' to see available interfaces. This interface must be connected to the subnet you want to monitor.",

  "_timing_settings": {
    "_description": "Interval configurations that control how frequently the monitor performs different types of network checks. Lower values = more responsive but higher CPU/network usage. Higher values = less resource usage but slower detection of changes.",
    "_detection_timing": {
      "_new_device_discovery": "Average time to discover a NEW device coming online: Approximately (discovery_run_time + discovery_interval_seconds) / 2. With defaults (15s scan + 30s pause = 45s cycle), average discovery time is ~22 seconds. Worst case: 45 seconds if device appears just after a scan completes.",
      "_state_change_detection_online": "Average time to detect a known device coming ONLINE: Approximately (polling_run_time + polling_interval_seconds) / 2, OR next discovery scan, whichever comes first. Polling is usually faster. With 20 devices and defaults (20 × 3s = 60s + 3s pause = 63s cycle), average is ~31 seconds. Can also be detected immediately if discovery scan happens to run first. Note: The timestamp precision for when the device actually went OFFLINE previously is limited by the polling cycle time - we only know it was offline when last checked.",
      "_state_change_detection_offline": "Average time to detect a device going OFFLINE: Approximately (polling_run_time + polling_interval_seconds) / 2. Only the polling thread detects offline state. With 20 devices and defaults (63s cycle), average is ~31 seconds. To improve offline detection speed: reduce ping_timeout_seconds or ping_count, or run pings in parallel (requires code changes). Note: The timestamp precision for when the device actually went ONLINE previously is limited by the polling cycle time - we only know it was online when last checked."
    }
  },
  "discovery_interval_seconds": 30,
  "_discovery_interval_info": "Pause time (in seconds) between discovery scans. NOTE: This is the sleep time AFTER each scan completes, not the total interval. The actual time between scan starts = run time + this pause. Estimated run time: 5-30 seconds for typical home networks (depends on network size and response times). A /24 subnet with arp-scan typically takes 5-15 seconds, plus up to 60 seconds for fping ARP cache pre-population if enabled. Total cycle time example: 15s scan + 30s pause = 45s between scan starts. Recommended pause: 30-300 seconds. Lower values detect new devices faster but increase network/CPU usage. Default: 30",

  "_discovery_trigger_file": "trigger-discovery",
  "_discovery_trigger_file_info": "Optional file path to trigger on-demand discovery scans. When this file exists, the monitor immediately runs a discovery scan and deletes the file. Useful for running discovery manually without restarting the service. Example: Set discovery_interval_seconds to 86400 (1 day) for infrequent automatic scans, then 'touch trigger-discovery' to scan on-demand. The monitor checks for this file every 5 seconds during sleep. Uncomment to enable.",

  "polling_interval_seconds": 3,
  "_polling_interval_info": "Pause time (in seconds) between polling cycles. NOTE: This is the sleep time AFTER each polling round completes, not the total interval. The actual time between polling starts = run time + this pause. Estimated run time: (number_of_devices × ping_timeout_seconds). For example, 20 devices with 3-second ping timeout = ~60 seconds of pinging (done sequentially), plus this 3-second pause = 63s total cycle. For faster state change detection, reduce ping_timeout_seconds rather than this value. Recommended pause: 1-10 seconds. Default: 3",

  "_ping_settings": {
    "_description": "Configuration for ping-based connectivity checks used by the polling thread to determine if known devices are online or offline"
  },
  "ping_timeout_seconds": 3,
  "_ping_timeout_info": "Maximum time (in seconds) to wait for a ping response before considering a device offline. Should be less than or equal to polling_interval_seconds to avoid overlapping checks. Recommended: 1-5 seconds. Default: 3",

  "ping_count": 3,
  "_ping_count_info": "Number of ping packets to send per check. Higher values = more reliable but slower. Value of 1 = fastest but may have false negatives. Value of 3-5 = good balance. Default: 3",

  "parallel_ping_workers": 10,
  "_parallel_ping_workers_info": "Number of parallel threads to use for pinging devices. With parallel polling, all devices are checked simultaneously instead of sequentially. Higher values = faster polling cycles but more CPU/network usage. The monitor automatically staggers ping starts evenly across the polling interval (stagger = polling_interval_seconds / number_of_devices) to spread network/CPU load. For example, 20 devices with 3s interval = 150ms stagger between pings. Value of 10-20 workers is typical for home networks. Default: 10",

  "_scanner_settings": {
    "_description": "Settings that control which network scanning tool is used for device discovery and how the ARP cache is managed"
  },
  "scanner": "arp-scan",
  "_scanner_info": "Primary network scanning tool for device discovery. Options: 'arp-scan' (faster, more reliable, recommended) or 'nmap' (slower but more widely available). The monitor will automatically fall back to nmap if arp-scan is not installed. Install arp-scan with: sudo apt-get install arp-scan",

  "prepopulate_arp": true,
  "_prepopulate_arp_info": "If true, runs fping to populate the system ARP cache before scanning. This significantly improves arp-scan accuracy and speed by ensuring the ARP cache is warm. Recommended: true. Requires fping to be installed: sudo apt-get install fping. If fping is not installed, this setting is safely ignored.",

  "_storage_settings": {
    "_description": "File paths and directory locations for device state storage and application logs"
  },
  "devices_dir": "devices",
  "_devices_dir_info": "Directory path (relative to monitor.py) where device state files are stored. Each monitored device gets its own CSV file named by MAC address (with colons removed). Files contain timestamp,ip,mac,status,interval_seconds on each line. This directory must be writable by the user running monitor.py. Do NOT run monitor.py with sudo or files will be owned by root.",

  "_logging_settings": {
    "_description": "Application logging configuration. Logs always go to stdout (captured by systemd journal when run as service). File logging is optional and intended for testing/debugging only."
  },
  "log_level": "INFO",
  "_log_level_info": "Logging verbosity level. Options (from least to most verbose): 'ERROR', 'WARNING', 'INFO', 'DEBUG'. 'INFO' shows all state changes and important events. 'DEBUG' shows detailed scanning operations and is useful for troubleshooting. 'WARNING' only shows problems. Default: INFO",

  "_vendor_lookup_settings": {
    "_description": "MAC address vendor identification configuration. Used to identify device manufacturers from MAC addresses for easier device identification in logs."
  },
  "common_vendors": {
    "_description": "Optional dictionary mapping MAC prefixes (first 6 hex digits) to vendor names for faster local lookup before querying external API. Example: '00:1A:2B': 'Apple Inc.'. This is a performance optimization to reduce API calls for common devices on your network. Leave empty to always use API lookup."
  },

  "_device_overrides_settings": {
    "_description": "Per-device configuration overrides based on vendor name regex patterns. Allows customizing ping behavior, intervals, and other settings for specific device types. Patterns are matched against the vendor portion of device hostnames (e.g., 'EspressifInc' from 'EspressifInc-4DE4'). First matching pattern wins."
  },
  "device_overrides": {
    "_description": "Dictionary of regex patterns to config overrides. Only specify values that differ from defaults (kustomize-style overlay). Any config parameter can be overridden. Examples below show common use cases.",
    "_example_espressif": "Pattern 'Espressif.*' matches devices like 'EspressifInc-4DE4'. ESP devices often have flaky Wi-Fi, so increase ping count/timeout for reliability.",
    "_example_tuya": "Pattern 'Tuya.*' matches devices like 'TuyaSmartInc-F412'. IoT devices may sleep to save power, so reduce polling frequency to avoid battery drain.",
    "_example_disable_polling": "Pattern 'Google.*' with disable_polling=true means Google devices are discovered but not continuously polled. Useful for uninteresting devices.",
    "_usage": "Uncomment and customize the examples below, or add your own patterns:",
    "_Espressif.*": {
      "_ping_count": 5,
      "_ping_timeout_seconds": 5,
      "__comment": "Espressif ESP devices (ESP8266, ESP32) often have unreliable Wi-Fi. More pings = fewer false offline detections."
    },
    "_Tuya.*": {
      "_polling_interval_seconds": 60,
      "__comment": "Tuya smart home devices may sleep between operations. Poll less frequently to reduce wake-ups and save battery."
    },
    "_Google.*": {
      "_disable_polling": true,
      "__comment": "Google devices will be discovered but not continuously polled. Saves resources for devices you don't care to monitor closely."
    }
  }
}
